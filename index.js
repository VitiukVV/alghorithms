// Сума всіх чисел в діапазоні
// Вам буде надано масив з двох чисел. Поверніть суму цих двох чисел плюс суму всіх чисел між ними. Найменше число не завжди буде на першому місці.

// Наприклад, sumAll([4,1]) має повертати 10, оскільки сума всіх чисел між 1 і 4 (включно з ними) дорівнює 10.

// function sumAll(arr) {
//   const sortedArr = arr.sort((a, b) => a - b);
//   let newArr = [];
//   for (let i = sortedArr[0]; i <= sortedArr[sortedArr.length - 1]; i += 1) {
//     newArr.push(i);
//   }
//   const sum = newArr.reduce((prev, item) => {
//     return prev + item;
//   }, 0);
//   return sum;
// }

// console.log(sumAll([1, 4]));

// Різниця між двома масивами
// Порівняйте два масиви і поверніть новий масив з елементами, знайденими лише в одному з двох наданих масивів. Іншими словами, поверніть симетричну різницю двох масивів.

// Примітка: ви можете повернути масив з його елементами в будь-якому порядку.
// function diffArray(arr1, arr2) {
//   const newArr = [...arr1, ...arr2];
//   const unique = newArr.filter((item) => {
//     return !arr1.includes(item) || !arr2.includes(item);
//   });
//   return unique;
// }

// console.log(diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]));
// console.log(
//   diffArray(
//     ["diorite", "andesite", "grass", "dirt", "pink wool", "dead shrub"],
//     ["diorite", "andesite", "grass", "dirt", "dead shrub"]
//   )
// );

// Пошук та знищення
// Вам буде надано початковий масив як перший аргумент до функції destroyer, який супроводжується одним або більше аргументами. Видаліть всі елементи з початкового масиву, які мають таке ж значення, як ці аргументи.

// Функція має приймати невизначену кількість аргументів; таку функцію часто називають варіадичною. Ви можете отримати доступ до додаткових аргументів, додавши залишковий параметр до визначення функції або використавши об’єкт arguments.
// function destroyer(arr, ...args) {
//   const newArr = arr.filter((item) => !args.includes(item));
//   return newArr;
// }

// console.log(destroyer([1, 2, 3, 1, 2, 3], 2, 3));

// Де ж ти, Ромео?
// Напишіть функцію, яка проглядає масив об’єктів (перший аргумент) і повертає масив усіх об’єктів, які мають однакові пари імен та значень (другий аргумент). Кожна пара імен та значень вихідного об'єкта повинна бути в об’єкті з колекції, якщо він необхідний у повернутому масиві.

// Наприклад, якщо першим аргументом є [{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }] та другим аргументом є { last: "Capulet" }, тоді потрібно повернути третій об’єкт з масиву (перший аргумент), оскільки він містить ім’я та його значення, яке було передане до другого аргументу.

// function whatIsInAName(collection, source) {
//   return collection.filter((item) => {
//     return Object.keys(source).every((key) => item[key] === source[key]);
//   });
// }

// console.log(
//   whatIsInAName(
//     [
//       { first: "Romeo", last: "Montague" },
//       { first: "Mercutio", last: null },
//       { first: "Tybalt", last: "Capulet" },
//     ],
//     { last: "Capulet" }
//   )
// );

// Шашличний регістр
// Перетворіть рядок в шашличний регістр. У шашличному регістрі всі-слова-в-нижньому-регістрі-та-розділені-рискою.
// function spinalCase(str) {
//   return str
//     .split(/\s|_|(?=[A-Z])/)
//     .join("-")
//     .toLowerCase();
// }

// console.log(spinalCase("This Is Spinal Tap"));

// Поросяча латина
// Поросяча латина — це спосіб шифрування англійських слів. Правила такі:

// - Якщо слово починається з приголосного звуку, то перший приголосний або сполучення приголосних переміщуються в кінець слова і додається ay.

// - Якщо слово починається з голосного звуку, то вкінці просто додається way.

// Перекладіть поданий рядок на поросячу латину. Відомо, що при вводі всі рядки будуть складатись з англійських слів у нижньому регістрі.

function translatePigLatin(str) {}

console.log(translatePigLatin("consonant"));
